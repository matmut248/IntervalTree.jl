using LinearAlgebraicRepresentation
Lar = LinearAlgebraicRepresentation
using IntervalTrees
using BenchmarkTools
using OrderedCollections
using Base.Threads
"""
Possibili errori di compilazione dovuti al package Triangle.jl
Per risolvere aggiungere questo file nel package LinearAlgebraicRepresentation.jl ed eliminare tutti i riferimenti a Triangle.jl
"""

"""
	spaceindex(model::Lar.LAR)::Array{Array{Int,1},1}

	Generation of *space indexes* for all ``(d-1)``-dim cell members of `model`.

	*Spatial index* made by ``d`` *interval-trees* on
	bounding boxes of ``sigma in S_{d−1}``. Spatial queries solved by
	intersection of ``d`` queries on IntervalTrees generated by
	bounding-boxes of geometric objects (LAR cells).

	The return value is an array of arrays of `int`s, indexing cells whose
	containment boxes are intersecting the containment box of the first cell.
	According to Hoffmann, Hopcroft, and Karasick (1989) the worst-case complexity of
	Boolean ops on such complexes equates the total sum of such numbers.

	# Examples 2D

	```
	julia> V = hcat([[0.,0],[1,0],[1,1],[0,1],[2,1]]...);

	julia> EV = [[1,2],[2,3],[3,4],[4,1],[1,5]];

	julia> Sigma = Lar.spaceindex((V,EV))
	5-element Array{Array{Int64,1},1}:
	[4, 5, 2]
	[1, 3, 5]
	[4, 5, 2]
	[1, 3, 5]
	[4, 1, 3, 2]
	```

	Array{Int64,2}

	From `model2d` value, available in `?input_collection` docstring:

	```julia
	julia> Sigma =  spaceindex(model2d);
	```

	# Example 3D
	V = hcat([[0.,0,0],[1,0,3],[1,1,2],[0,1,1],[2,1,0]]...);
	```julia
	model = model3d
	Sigma =  spaceindex(model3d);
	Sigma
	```

	spaceindex, dato un modello, restituisce un array di array dove l'elemento i-esimo rappresenta
	quali intersezioni ha il bounding box i-esimo con gli altri bounding box
"""
function spaceindex(model::Lar.LAR)::Array{Array{Int,1},1}
    V,CV = model[1:2]
    dim = size(V,1)
    
    cellpoints = [ V[:,CV[k]]::Lar.Points for k=1:length(CV) ]		    #calcola le celle
    bboxes = [hcat(boundingbox(cell)...) for cell in cellpoints]    #calcola i boundingbox delle celle
    
    xboxdict = coordintervals(1,bboxes)
    yboxdict = coordintervals(2,bboxes)

    # xs,ys sono di tipo IntervalTree
    xs = createIntervalTree(xboxdict)
    ys = createIntervalTree(yboxdict)
    
    xcovers = boxcovering(bboxes, 1, xs)                        #lista delle intersezioni dei bb sulla coordinata x
    ycovers = boxcovering(bboxes, 2, ys)                        #lista delle intersezioni dei bb sulla coordinata x
    covers = [intersect(pair...) for pair in zip(xcovers,ycovers)]  #lista delle intersezioni dei bb su entrambe le coordinate

    if dim == 3
		zboxdict = coordintervals(3,bboxes)
		zs = createIntervalTree(zboxdict)
		zcovers = boxcovering(bboxes, 3, zs)
		covers = [intersect(pair...) for pair in zip(zcovers,covers)]
    end
    
    removeSelfIntersection!(covers)       #rimozione delle intersezioni con se stesso
    return covers
end


"""
La funzione boundingbox serve a creare il bounding Box di una cella,
cioè la scatola di misura più piccola (area, volume, ipervolume) entro cui sono contenuti tutti i punti.
"""
function boundingbox(vertices::Lar.Points)
    firstDim = vertices[1,:]
    secondDim = vertices[2,:]
    if (size(vertices,1)==3)
        thirdDim = vertices[3,:]
        minimum = hcat([min(firstDim...), min(secondDim...), min(thirdDim...)])
        maximum = hcat([max(firstDim...), max(secondDim...), max(thirdDim...)])
    else
        minimum = hcat([min(firstDim...), min(secondDim...)])
        maximum = hcat([max(firstDim...), max(secondDim...)])
    end
    return minimum,maximum
 end
    

"""
coordintervals crea un dizionario ordinato dove la chiave è l'intervallo su una coordinata, e come valore associato ha
l'indice dell'intervallo corrispondente nel boundig box
"""
function coordintervals(coord,bboxes)
    boxdict = OrderedDict{Array{Float64,1},Array{Int64,1}}()
    for (h,box) in enumerate(bboxes)
        key = box[coord,:]
        if haskey(boxdict,key) == false
            boxdict[key] = [h]
        else
            push!(boxdict[key], h)
        end
    end
    return boxdict
end

"""
boxcovering calcola quali bounding box si intersecano tra loro.
"""
function boxcovering(bboxes, index, tree)
    covers = [[zero(eltype(Int64))] for k=1:length(bboxes)]		#zero(eltype(Int64)) serve per rendere covers type stable
    @threads for (i,boundingbox) in collect(enumerate(bboxes))
        extent = bboxes[i][index,:]
        iterator = IntervalTrees.intersect(tree, tuple(extent...))
        addIntersection!(covers, i, iterator)
    end
    return covers
end

"""
addIntersection! aggiunge in 'covers' in i-esima posizione tutti i bounding box
che intersecano l'i-esimo bounding box
"""
function addIntersection!(covers::Array{Array{Int64,1},1}, i::Int64, iterator)
    splice!(covers[i],1)		#splice serve a togliere gli zeri iniziali all'interno di covers
    for x in iterator
        append!(covers[i],x.value)
    end
end

"""
dato un dizionario ordinato crea un intervalTrees cioè una struttura dati che contiene intervalli 
e che consente di trovare in modo efficiente tutti gli intervalli che si sovrappongono a un determinato intervallo o punto. 
"""
function createIntervalTree(boxdict::AbstractDict{Array{Float64,1},Array{Int64,1}})
    tree = IntervalTrees.IntervalMap{Float64,Array}()
    for (key, boxset) in boxdict
        tree[tuple(key...)] = boxset
    end
    return tree
end

"""
rimuove le intersezioni contenute in 'covers' che i boundingbox hanno con se stessi 
"""
function removeSelfIntersection!(covers::Array{Array{Int64,1},1})
	@threads for k=1:length(covers)
        covers[k] = setdiff(covers[k],[k])	#toglie le intersezioni con se stesso 
    end
end

